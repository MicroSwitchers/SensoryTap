<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="A sensory cause and effect app for early childhood vision development">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sensory Tap">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Sensory Tap</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --switch-color-main: #ff0000;
            --switch-color-dark: #770000;
            --switch-shadow: rgba(255, 0, 0, 0.3);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            /* Support for iOS safe areas and notches */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* Fullscreen mode enhancements */
        html:fullscreen,
        html:-webkit-full-screen,
        html:-moz-full-screen,
        html:-ms-fullscreen {
            width: 100%;
            height: 100%;
        }

        body:fullscreen,
        body:-webkit-full-screen,
        body:-moz-full-screen,
        body:-ms-fullscreen {
            width: 100%;
            height: 100%;
        }

        #canvas {
            display: block;
        }

        /* --- The Big Target Button Styles --- */
        #cue-area {
            position: absolute;
            background: radial-gradient(circle at center, var(--switch-color-main) 0%, var(--switch-color-dark) 100%);
            border: 5px solid #1a1a1a;
            box-shadow: 0 0 30px var(--switch-shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            opacity: 1;
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 3s ease-in-out;
        }

        /* 1. Bottom (Default) */
        #cue-area.pos-bottom {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 360px;
            max-width: 90vw;
            height: 130px;
            border-radius: 180px 180px 0 0;
            border-bottom: none;
            background: radial-gradient(circle at center 100%, var(--switch-color-main) 0%, var(--switch-color-dark) 100%);
        }
        #cue-area.pos-bottom:active { height: 100px; }

        /* 2. Top */
        #cue-area.pos-top {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 360px;
            max-width: 90vw;
            height: 130px;
            border-radius: 0 0 180px 180px;
            border-top: none;
            background: radial-gradient(circle at center 0%, var(--switch-color-main) 0%, var(--switch-color-dark) 100%);
        }
        #cue-area.pos-top:active { height: 100px; }

        /* 3. Left */
        #cue-area.pos-left {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 130px;
            height: 360px;
            max-height: 80vh;
            border-radius: 0 180px 180px 0;
            border-left: none;
            background: radial-gradient(circle at 0% 50%, var(--switch-color-main) 0%, var(--switch-color-dark) 100%);
        }
        #cue-area.pos-left:active { width: 100px; }

        /* 4. Right */
        #cue-area.pos-right {
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            width: 130px;
            height: 360px;
            max-height: 80vh;
            border-radius: 180px 0 0 180px;
            border-right: none;
            background: radial-gradient(circle at 100% 50%, var(--switch-color-main) 0%, var(--switch-color-dark) 100%);
        }
        #cue-area.pos-right:active { width: 100px; }

        /* 5. Center (Middle of Screen) */
        #cue-area.pos-center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 240px;
            height: 240px;
            border-radius: 50%;
            background: radial-gradient(circle at center, var(--switch-color-main) 0%, var(--switch-color-dark) 100%);
        }
        #cue-area.pos-center:active { width: 220px; height: 220px; }

        @keyframes wave-pulse {
            0%, 100% { box-shadow: 0 0 20px var(--switch-shadow); }
            50% { box-shadow: 0 0 60px var(--switch-shadow); }
        }

        .pulse {
            animation: wave-pulse 6s infinite ease-in-out;
        }

        /* --- Hint Text Positioning --- */
        .hint-text {
            position: absolute;
            color: #ffffff;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 0.9rem;
            font-weight: bold;
            letter-spacing: 0.5em;
            opacity: 0.2;
            pointer-events: none;
            text-transform: uppercase;
            z-index: 11;
            transition: all 0.4s ease;
            white-space: nowrap;
        }

        .hint-text.pos-bottom { bottom: 20px; left: 50%; transform: translateX(-50%); }
        .hint-text.pos-top { top: 20px; left: 50%; transform: translateX(-50%); }
        .hint-text.pos-left { left: 20px; top: 50%; transform: translateY(-50%) rotate(-90deg); }
        .hint-text.pos-right { right: 20px; top: 50%; transform: translateY(-50%) rotate(90deg); }
        .hint-text.pos-center { top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.4; }


        /* Parent Settings Button */
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 50;
            color: white;
            opacity: 0.3;
            transition: opacity 0.3s, transform 0.2s;
        }

        #settings-btn:active {
            transform: scale(0.9);
            opacity: 0.8;
        }

        /* Settings Drawer */
        #settings-drawer {
            position: absolute;
            top: 0;
            right: -360px; /* Hidden state */
            width: 340px;
            max-width: 85vw; /* Responsive width for mobile */
            height: 100%;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: right 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            padding: 40px 24px;
            color: white;
            box-shadow: -10px 0 30px rgba(0,0,0,0.5);
            overflow-y: auto; /* Enable vertical scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        #settings-drawer.open {
            right: 0;
        }

        .setting-section {
            margin-bottom: 30px;
        }

        .setting-label {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 12px;
            opacity: 0.6;
            font-weight: 600;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .color-opt {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 12px;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-opt.active {
            border-color: white;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        .range-btn {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            text-align: left;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.05);
            transition: background 0.2s, border-color 0.2s;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .range-btn.active {
            background: rgba(255,255,255,0.12);
            border-color: rgba(255,255,255,0.4);
        }

        .range-name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .range-preview {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            opacity: 0.9;
        }

        /* Toggle Button Style */
        .toggle-btn {
            width: 100%;
            padding: 16px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            transition: background 0.2s, border-color 0.2s;
        }

        .toggle-btn.active {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.5);
            color: #4ade80;
        }

        .toggle-status {
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Position Options */
        .pos-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .pos-btn {
            padding: 12px 0;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pos-btn.active {
            background: rgba(255,255,255,0.2);
            border-color: white;
            color: white;
        }

        /* Slider Style */
        .slider-container {
            width: 100%;
            padding: 16px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .slider-value {
            color: white;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        #close-drawer {
            margin-top: 10px;
            width: 100%;
            padding: 16px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.05em;
            transition: background 0.2s;
        }
        
        #close-drawer:active {
            background: rgba(255,255,255,0.2);
        }

        /* Hold indicator circle */
        #hold-progress {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            border-top-color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .holding #hold-progress {
            opacity: 1;
            animation: spin 1s linear infinite;
        }

        /* Hold tooltip */
        #hold-tooltip {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            white-space: nowrap;
            z-index: 60;
        }

        #hold-tooltip.show {
            opacity: 1;
        }

        /* Custom scrollbar for webkit */
        #settings-drawer::-webkit-scrollbar {
            width: 6px;
        }
        #settings-drawer::-webkit-scrollbar-track {
            background: transparent;
        }
        #settings-drawer::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>
    <!-- Cue Area default: pos-bottom -->
    <div id="cue-area" class="pulse pos-bottom"></div>

    <div id="settings-btn" role="button" aria-label="Open Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
        <div id="hold-progress"></div>
    </div>
    
    <div id="hold-tooltip">Hold for 2 seconds</div>

    <div id="settings-drawer">
        <h2 class="text-xl font-bold mb-8 tracking-wide">Parental Settings</h2>
        
        <div class="setting-section">
            <span class="setting-label">Animation Style</span>
            <div class="pos-grid" id="shape-options" style="grid-template-columns: 1fr 1fr; gap: 12px;">
                <!-- Shapes added via JS -->
            </div>
        </div>

        <div class="setting-section">
            <span class="setting-label">Color Theme</span>
            <div id="range-options">
                <!-- Ranges added via JS -->
            </div>
        </div>

        <div class="setting-section">
            <span class="setting-label">Interface Settings</span>
            
            <div id="fullscreen-options" style="margin-bottom: 15px;">
                <!-- Fullscreen toggle added via JS -->
            </div>
            
            <div style="margin-bottom: 15px;">
                <span class="setting-label">Button Color</span>
                <div class="color-grid" id="switch-color-options">
                    <!-- Colors added via JS -->
                </div>
            </div>
            
            <div id="visibility-options">
                <!-- Toggle added via JS -->
            </div>
            
            <div style="margin-top: 15px;">
                <span class="setting-label">Touch Target</span>
                <div class="pos-grid" id="interaction-options">
                    <!-- Added via JS -->
                </div>
            </div>

            <div style="margin-top: 15px;">
                <span class="setting-label">Tap Cooldown</span>
                <div class="pos-grid" id="cooldown-options">
                    <!-- Added via JS -->
                </div>
            </div>

            <div style="margin-top: 15px;">
                <span class="setting-label">Button Position</span>
                <div class="pos-grid" id="position-options">
                    <!-- Position buttons added via JS -->
                </div>
            </div>

            <div style="margin-top: 15px;">
                <span class="setting-label">Button Size</span>
                <div class="slider-container">
                    <div class="slider-header">
                        <span>Scale</span>
                        <span class="slider-value" id="button-scale-value">100%</span>
                    </div>
                    <input type="range" id="button-scale-slider" min="50" max="250" step="10" value="150">
                </div>
            </div>
        </div>

        <div id="close-drawer">Close</div>
        <p class="mt-6 text-xs opacity-30 text-center uppercase tracking-widest">By Niall Brown Early Childhood Vision consultant (ECVC)</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const cueArea = document.getElementById('cue-area');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsDrawer = document.getElementById('settings-drawer');
        const closeDrawer = document.getElementById('close-drawer');
        const holdTooltip = document.getElementById('hold-tooltip');

        let width, height;
        let elements = [];
        let time = 0;

        // --- Settings State ---
        let currentHue = 240;
        const hueShiftPerTouch = 15;
        let activeHueRange = [0, 360]; 
        let isSwitchEnabled = true;
        let currentPosition = 'pos-bottom'; 
        let tapMode = 'anywhere'; // 'anywhere' or 'button'
        let cooldownMode = 'animation'; // 'animation', '8s', '10s'
        let isCooldown = false;
        let cooldownTimer = null;
        let buttonRestoreTimer = null;
        
        // Animation customization
        let animationShape = 'waves'; // 'waves', 'bubbles'
        let buttonScale = 1.5; // Button size scale (0.5 = min, 1.5 = default, up to 2.5)
        let isFullscreen = false; // Track fullscreen state

        // Load saved preferences
        function loadPreferences() {
            const saved = localStorage.getItem('sensoryTapPrefs');
            if (saved) {
                try {
                    const prefs = JSON.parse(saved);
                    if (prefs.isSwitchEnabled !== undefined) isSwitchEnabled = prefs.isSwitchEnabled;
                    if (prefs.currentPosition) currentPosition = prefs.currentPosition;
                    if (prefs.tapMode) tapMode = prefs.tapMode;
                    if (prefs.cooldownMode) cooldownMode = prefs.cooldownMode;
                    if (prefs.activeSwitchColorIndex !== undefined) activeSwitchColorIndex = prefs.activeSwitchColorIndex;
                    if (prefs.activeHueRange) activeHueRange = prefs.activeHueRange;
                    if (prefs.currentHue !== undefined) currentHue = prefs.currentHue;
                    if (prefs.animationShape) animationShape = prefs.animationShape;
                    if (prefs.buttonScale !== undefined) buttonScale = prefs.buttonScale;
                } catch (e) {
                    console.error('Failed to load preferences:', e);
                }
            }
        }

        // Save preferences
        function savePreferences() {
            const prefs = {
                isSwitchEnabled,
                currentPosition,
                tapMode,
                cooldownMode,
                activeSwitchColorIndex,
                activeHueRange,
                currentHue,
                animationShape,
                buttonScale
            };
            localStorage.setItem('sensoryTapPrefs', JSON.stringify(prefs));
        }

        const hueRanges = [
            { label: "Red - Orange - Yellow", range: [0, 60] },
            { label: "Yellow - Green - Lime", range: [60, 140] },
            { label: "Green - Teal - Blue", range: [120, 240] },
            { label: "Blue - Purple - Red", range: [220, 360] },
            { label: "Full Spectrum", range: [0, 360] }
        ];

        const switchColors = [
            { main: '#ef4444', dark: '#7f1d1d', shadow: 'rgba(239, 68, 68, 0.4)' }, // Red
            { main: '#22c55e', dark: '#14532d', shadow: 'rgba(34, 197, 94, 0.4)' }, // Green
            { main: '#3b82f6', dark: '#1e3a8a', shadow: 'rgba(59, 130, 246, 0.4)' }, // Blue
            { main: '#eab308', dark: '#713f12', shadow: 'rgba(234, 179, 8, 0.4)' }, // Yellow
            { main: '#a855f7', dark: '#581c87', shadow: 'rgba(168, 85, 247, 0.4)' }, // Purple
            { main: '#f97316', dark: '#7c2d12', shadow: 'rgba(249, 115, 22, 0.4)' }, // Orange
            { main: '#ffffff', dark: '#525252', shadow: 'rgba(255, 255, 255, 0.3)' }  // White
        ];

        let activeSwitchColorIndex = 0;

        // --- Initialize UI ---
        function setupSettingsUI() {
            // Apply saved position classes
            cueArea.className = `pulse ${currentPosition}`;
            
            // Apply saved switch color
            updateSwitchColor();
            
            // Apply saved button visibility
            cueArea.style.display = isSwitchEnabled ? 'flex' : 'none';
            
            // Setup Visibility Toggle
            const visibilityContainer = document.getElementById('visibility-options');
            const toggleBtn = document.createElement('div');
            toggleBtn.className = `toggle-btn ${isSwitchEnabled ? 'active' : ''}`;
            toggleBtn.innerHTML = `<span>Big Target Button</span><span class="toggle-status">${isSwitchEnabled ? 'ON' : 'OFF'}</span>`;
            toggleBtn.onclick = () => {
                isSwitchEnabled = !isSwitchEnabled;
                toggleBtn.classList.toggle('active', isSwitchEnabled);
                const statusSpan = toggleBtn.querySelector('.toggle-status');
                statusSpan.textContent = isSwitchEnabled ? 'ON' : 'OFF';
                cueArea.style.display = isSwitchEnabled ? 'flex' : 'none';
                savePreferences();
            };
            visibilityContainer.appendChild(toggleBtn);

            // Setup Fullscreen Toggle
            const fullscreenContainer = document.getElementById('fullscreen-options');
            const fullscreenBtn = document.createElement('div');
            fullscreenBtn.className = `toggle-btn ${isFullscreen ? 'active' : ''}`;
            fullscreenBtn.innerHTML = `<span>Fullscreen Mode</span><span class="toggle-status">${isFullscreen ? 'ON' : 'OFF'}</span>`;
            fullscreenBtn.onclick = () => {
                toggleFullscreen();
            };
            fullscreenContainer.appendChild(fullscreenBtn);

            // Setup Interaction Mode Options
            const interactionContainer = document.getElementById('interaction-options');
            const interactionModes = [
                { id: 'anywhere', label: 'Anywhere' },
                { id: 'button', label: 'Button Only' }
            ];
            
            interactionModes.forEach(mode => {
                const btn = document.createElement('div');
                btn.className = `pos-btn ${mode.id === tapMode ? 'active' : ''}`;
                btn.textContent = mode.label;
                btn.onclick = () => {
                    tapMode = mode.id;
                    document.querySelectorAll('#interaction-options .pos-btn').forEach(el => {
                        el.classList.toggle('active', el.textContent === mode.label);
                    });
                    savePreferences();
                };
                interactionContainer.appendChild(btn);
            });

            // Setup Cooldown Options
            const cooldownContainer = document.getElementById('cooldown-options');
            const cooldownModes = [
                { id: 'animation', label: 'End of Animation' },
                { id: '8s', label: '8 Sec' },
                { id: '10s', label: '10 Sec' }
            ];
            
            cooldownModes.forEach(mode => {
                const btn = document.createElement('div');
                btn.className = `pos-btn ${mode.id === cooldownMode ? 'active' : ''}`;
                btn.textContent = mode.label;
                btn.onclick = () => {
                    cooldownMode = mode.id;
                    document.querySelectorAll('#cooldown-options .pos-btn').forEach(el => {
                        el.classList.toggle('active', el.textContent === mode.label);
                    });
                    savePreferences();
                };
                cooldownContainer.appendChild(btn);
            });

            // Setup Position Options
            const posContainer = document.getElementById('position-options');
            const positions = [
                { id: 'pos-top', label: 'Top' },
                { id: 'pos-bottom', label: 'Bottom' },
                { id: 'pos-left', label: 'Left' },
                { id: 'pos-right', label: 'Right' },
                { id: 'pos-center', label: 'Center' }
            ];
            
            positions.forEach(pos => {
                const btn = document.createElement('div');
                // Make center span full width or just list them
                btn.className = `pos-btn ${pos.id === currentPosition ? 'active' : ''}`;
                if (pos.id === 'pos-center') btn.style.gridColumn = 'span 2'; // make center slightly wider or prominent
                btn.textContent = pos.label;
                btn.onclick = () => {
                    // Remove old class
                    cueArea.classList.remove(currentPosition);
                    
                    // Update state
                    currentPosition = pos.id;
                    
                    // Add new class
                    cueArea.classList.add(currentPosition);

                    // Update button size for new position
                    updateButtonSize();

                    // Update UI buttons
                    document.querySelectorAll('#position-options .pos-btn').forEach(el => {
                        el.classList.toggle('active', el.textContent === pos.label);
                    });
                    
                    savePreferences();
                };
                posContainer.appendChild(btn);
            });


            // Setup Color Options
            const colorContainer = document.getElementById('switch-color-options');
            switchColors.forEach((color, idx) => {
                const opt = document.createElement('div');
                opt.className = `color-opt ${idx === activeSwitchColorIndex ? 'active' : ''}`;
                opt.style.backgroundColor = color.main;
                opt.onclick = () => {
                    activeSwitchColorIndex = idx;
                    updateSwitchColor();
                    document.querySelectorAll('.color-opt').forEach((el, i) => {
                        el.classList.toggle('active', i === idx);
                    });
                    savePreferences();
                };
                colorContainer.appendChild(opt);
            });

            // Setup Range Options
            const rangeContainer = document.getElementById('range-options');
            hueRanges.forEach((r, idx) => {
                const btn = document.createElement('div');
                const isActive = JSON.stringify(r.range) === JSON.stringify(activeHueRange);
                btn.className = `range-btn ${isActive ? 'active' : ''}`;
                
                const label = document.createElement('span');
                label.className = 'range-name';
                label.textContent = r.label;
                btn.appendChild(label);

                const preview = document.createElement('div');
                preview.className = 'range-preview';
                
                const [min, max] = r.range;
                if (min === 0 && max === 360) {
                     preview.style.background = 'linear-gradient(to right, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000)';
                } else {
                     preview.style.background = `linear-gradient(to right, hsl(${min}, 85%, 50%), hsl(${max}, 85%, 50%))`;
                }
                btn.appendChild(preview);

                btn.onclick = () => {
                    activeHueRange = r.range;
                    currentHue = r.range[0]; 
                    document.querySelectorAll('.range-btn').forEach((el, i) => {
                        el.classList.toggle('active', i === idx);
                    });
                    savePreferences();
                };
                rangeContainer.appendChild(btn);
            });

            // Setup Shape Options
            const shapeContainer = document.getElementById('shape-options');
            const shapes = [
                { id: 'waves', label: 'Waves' },
                { id: 'bubbles', label: 'Bubbles' }
            ];
            
            shapes.forEach(shape => {
                const btn = document.createElement('div');
                btn.className = `pos-btn ${shape.id === animationShape ? 'active' : ''}`;
                btn.textContent = shape.label;
                btn.onclick = () => {
                    animationShape = shape.id;
                    document.querySelectorAll('#shape-options .pos-btn').forEach(el => {
                        el.classList.toggle('active', el.textContent === shape.label);
                    });
                    savePreferences();
                };
                shapeContainer.appendChild(btn);
            });

            // Setup Button Size Slider
            const sizeSlider = document.getElementById('button-scale-slider');
            const sizeValue = document.getElementById('button-scale-value');
            
            // Set initial value
            sizeSlider.value = buttonScale * 100;
            sizeValue.textContent = `${Math.round(buttonScale * 100)}%`;
            
            // Handle slider changes
            sizeSlider.addEventListener('input', (e) => {
                buttonScale = e.target.value / 100;
                sizeValue.textContent = `${Math.round(buttonScale * 100)}%`;
                updateButtonSize();
                savePreferences();
            });
            
            // Apply initial button size
            updateButtonSize();
        }

        function updateButtonSize() {
            // Apply scale to button dimensions based on position
            const baseWidth = 360;
            const baseHeight = 130;
            const baseCenterSize = 240;
            
            const scaledWidth = baseWidth * buttonScale;
            const scaledHeight = baseHeight * buttonScale;
            const scaledCenterSize = baseCenterSize * buttonScale;
            
            // Update CSS custom properties for dynamic sizing
            cueArea.style.setProperty('--button-scale', buttonScale);
            
            // Apply sizes based on current position
            if (currentPosition === 'pos-bottom' || currentPosition === 'pos-top') {
                cueArea.style.width = `${scaledWidth}px`;
                cueArea.style.height = `${scaledHeight}px`;
                cueArea.style.borderRadius = currentPosition === 'pos-bottom' ? 
                    `${scaledWidth/2}px ${scaledWidth/2}px 0 0` : 
                    `0 0 ${scaledWidth/2}px ${scaledWidth/2}px`;
            } else if (currentPosition === 'pos-left' || currentPosition === 'pos-right') {
                cueArea.style.width = `${scaledHeight}px`;
                cueArea.style.height = `${scaledWidth}px`;
                cueArea.style.borderRadius = currentPosition === 'pos-right' ? 
                    `${scaledWidth/2}px 0 0 ${scaledWidth/2}px` : 
                    `0 ${scaledWidth/2}px ${scaledWidth/2}px 0`;
            } else if (currentPosition === 'pos-center') {
                cueArea.style.width = `${scaledCenterSize}px`;
                cueArea.style.height = `${scaledCenterSize}px`;
                cueArea.style.borderRadius = '50%';
            }
        }

        function updateSwitchColor() {
            const color = switchColors[activeSwitchColorIndex];
            document.documentElement.style.setProperty('--switch-color-main', color.main);
            document.documentElement.style.setProperty('--switch-color-dark', color.dark);
            document.documentElement.style.setProperty('--switch-shadow', color.shadow);
        }

        // --- Fullscreen Logic ---
        function toggleFullscreen() {
            if (!document.fullscreenElement && 
                !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && 
                !document.msFullscreenElement) {
                // Enter fullscreen
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { // Safari
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) { // Firefox
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) { // IE/Edge
                    elem.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function updateFullscreenButton() {
            isFullscreen = !!(document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement);
            
            const fullscreenBtn = document.querySelector('#fullscreen-options .toggle-btn');
            if (fullscreenBtn) {
                fullscreenBtn.classList.toggle('active', isFullscreen);
                const statusSpan = fullscreenBtn.querySelector('.toggle-status');
                if (statusSpan) {
                    statusSpan.textContent = isFullscreen ? 'ON' : 'OFF';
                }
            }
        }

        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
        document.addEventListener('mozfullscreenchange', updateFullscreenButton);
        document.addEventListener('MSFullscreenChange', updateFullscreenButton);

        // --- Hold-to-Open Settings Logic ---
        let holdTimer;
        let tooltipTimer;
        
        function startHold() {
            settingsBtn.classList.add('holding');
            
            // Show tooltip after a brief delay
            tooltipTimer = setTimeout(() => {
                holdTooltip.classList.add('show');
            }, 100);
            
            holdTimer = setTimeout(() => {
                settingsDrawer.classList.add('open');
                settingsBtn.classList.remove('holding');
                holdTooltip.classList.remove('show');
            }, 2000);
        }

        function endHold() {
            clearTimeout(holdTimer);
            clearTimeout(tooltipTimer);
            settingsBtn.classList.remove('holding');
            holdTooltip.classList.remove('show');
        }

        settingsBtn.addEventListener('mousedown', startHold);
        settingsBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); });
        window.addEventListener('mouseup', endHold);
        window.addEventListener('touchend', endHold);

        closeDrawer.onclick = () => settingsDrawer.classList.remove('open');

        // --- Animation Logic ---

        function init() {
            loadPreferences();
            resize();
            setupSettingsUI();
            animate();
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        window.addEventListener('resize', resize);

        class Bubble {
            constructor(x, y, hue, delay) {
                this.startX = x;
                this.startY = height + 50; // Start just below screen for smooth entry
                this.x = this.startX;
                this.y = this.startY;
                this.hue = hue;
                this.delay = delay;
                this.radius = 25 + Math.random() * 50; // Slightly larger minimum
                this.opacity = 0.7 + Math.random() * 0.2;
                this.speed = 1.2 + Math.random() * 1.5; // More consistent speed
                this.wobbleAmount = 20 + Math.random() * 40; // Gentler wobble
                this.wobbleSpeed = 0.015 + Math.random() * 0.02; // Smoother wobble
                this.wobblePhase = Math.random() * Math.PI * 2;
                this.life = 1.0;
                this.active = false;
                this.age = 0; // Track age for fade-in
                
                setTimeout(() => { this.active = true; }, this.delay);
            }

            update() {
                if (!this.active) return;
                
                this.age++;
                
                // Move upward
                this.y -= this.speed;
                
                // Wobble side to side
                this.wobblePhase += this.wobbleSpeed;
                this.x = this.startX + Math.sin(this.wobblePhase) * this.wobbleAmount;
                
                // Fade out as it gets higher
                const distanceTraveled = this.startY - this.y;
                const totalDistance = height * 1.2;
                this.life = 1 - (distanceTraveled / totalDistance);
                
                // Fade in during first 20 frames
                let fadeMultiplier = 1;
                if (this.age < 20) {
                    fadeMultiplier = this.age / 20;
                }
                this.opacity = this.life * 0.7 * fadeMultiplier;
            }

            draw() {
                if (!this.active || this.life <= 0 || this.y < -this.radius) return;
                
                ctx.save();
                
                // Draw bubble with gradient
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3, 
                    this.y - this.radius * 0.3, 
                    0,
                    this.x, 
                    this.y, 
                    this.radius
                );
                gradient.addColorStop(0, `hsla(${this.hue}, 90%, 75%, ${this.opacity})`);
                gradient.addColorStop(0.5, `hsla(${this.hue}, 85%, 60%, ${this.opacity * 0.85})`);
                gradient.addColorStop(1, `hsla(${this.hue}, 80%, 45%, ${this.opacity * 0.4})`);
                
                // Add soft glow
                ctx.shadowBlur = 12;
                ctx.shadowColor = `hsla(${this.hue}, 90%, 60%, ${this.opacity * 0.5})`;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Add brighter highlight
                const highlightGradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3, 
                    this.y - this.radius * 0.3, 
                    0,
                    this.x - this.radius * 0.3, 
                    this.y - this.radius * 0.3, 
                    this.radius * 0.4
                );
                highlightGradient.addColorStop(0, `rgba(255, 255, 255, ${this.opacity * 0.8})`);
                highlightGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
                
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.25, this.y - this.radius * 0.25, this.radius * 0.35, 0, Math.PI * 2);
                ctx.fillStyle = highlightGradient;
                ctx.fill();
                
                ctx.restore();
            }
        }

        class FluidWave {
            constructor(x, y, hue, delay, shape) {
                this.x = x;
                this.y = y;
                this.hue = hue;
                this.delay = delay;
                this.radius = 0;
                this.maxRadius = Math.max(width, height) * 1.8;
                this.opacity = 0.4;
                this.growth = 1.8; // Slower growth for calmer waves
                this.thickness = 35 + Math.random() * 25; // Thinner, more consistent
                this.amplitude = 8 + Math.random() * 10; // Reduced wobble
                this.frequency = 2 + Math.floor(Math.random() * 3); // Fewer waves
                this.phase = Math.random() * Math.PI * 2;
                this.life = 1.0;
                this.active = false;
                this.shape = shape || animationShape;
                this.age = 0; // Track age for fade-in effect
                
                // For stars
                this.points = 5; // Fixed 5 points for consistency
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.04; // Much faster rotation
                
                // Add scale pulsing and wobble for more interest
                this.scalePhase = Math.random() * Math.PI * 2;
                this.scaleSpeed = 0.03 + Math.random() * 0.02;
                this.wobbleX = 0;
                this.wobbleY = 0;
                this.wobbleSpeed = 0.02 + Math.random() * 0.02;
                this.wobbleAmount = 30 + Math.random() * 40;
                
                // Random shape variation for stars mode
                if (this.shape === 'stars') {
                    const shapes = ['star', 'diamond', 'circle'];
                    this.shapeVariation = shapes[Math.floor(Math.random() * shapes.length)];
                } else {
                    this.shapeVariation = null;
                }
                
                setTimeout(() => { this.active = true; }, this.delay);
            }

            update() {
                if (!this.active) return;
                this.age++;
                this.radius += this.growth;
                this.growth *= 0.996; // Slower deceleration for smoother movement
                this.life -= 0.002; // Slightly faster fade for calmer overall effect
                
                // Fade in during first 30 frames, then fade out based on life
                let fadeMultiplier = 1;
                if (this.age < 30) {
                    fadeMultiplier = this.age / 30; // Fade in
                }
                this.opacity = this.life * 0.4 * fadeMultiplier;
                
                this.rotation += this.rotationSpeed;
                
                // Add pulsing scale effect
                this.scalePhase += this.scaleSpeed;
                
                // Add wobble movement for stars
                if (this.shape === 'stars') {
                    this.wobbleX = Math.sin(this.scalePhase) * this.wobbleAmount * (this.life * 0.5);
                    this.wobbleY = Math.cos(this.scalePhase * 1.3) * this.wobbleAmount * (this.life * 0.5);
                }
            }

            draw() {
                if (!this.active || this.life <= 0) return;
                ctx.save();
                
                // Apply wobble offset for stars
                const drawX = this.shape === 'stars' ? this.x + this.wobbleX : this.x;
                const drawY = this.shape === 'stars' ? this.y + this.wobbleY : this.y;
                
                // Apply pulsing scale
                const scaleFactor = this.shape === 'stars' ? 1 + Math.sin(this.scalePhase) * 0.15 : 1;
                const drawRadius = this.radius * scaleFactor;
                
                ctx.beginPath();
                const segments = 80;
                
                if (this.shape === 'stars') {
                    // Draw different shapes based on variation
                    if (this.shapeVariation === 'diamond') {
                        // Diamond shape
                        ctx.beginPath();
                        ctx.moveTo(drawX, drawY - drawRadius);
                        ctx.lineTo(drawX + drawRadius * 0.6, drawY);
                        ctx.lineTo(drawX, drawY + drawRadius);
                        ctx.lineTo(drawX - drawRadius * 0.6, drawY);
                        ctx.closePath();
                    } else if (this.shapeVariation === 'circle') {
                        // Circle shape (solid)
                        ctx.beginPath();
                        ctx.arc(drawX, drawY, drawRadius * 0.7, 0, Math.PI * 2);
                        ctx.closePath();
                    } else {
                        // Star shape (default)
                        for (let i = 0; i < this.points * 2; i++) {
                            const angle = (i / (this.points * 2)) * Math.PI * 2 + this.rotation;
                            const r = i % 2 === 0 ? drawRadius : drawRadius * 0.5;
                            const px = drawX + Math.cos(angle) * r;
                            const py = drawY + Math.sin(angle) * r;
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                    }
                    
                    // Create gradient for all shapes
                    const gradient = ctx.createRadialGradient(drawX, drawY, 0, drawX, drawY, drawRadius);
                    gradient.addColorStop(0, `hsla(${this.hue}, 90%, 70%, ${this.opacity * 0.9})`);
                    gradient.addColorStop(0.5, `hsla(${this.hue}, 85%, 55%, ${this.opacity * 0.7})`);
                    gradient.addColorStop(1, `hsla(${this.hue}, 80%, 40%, ${this.opacity * 0.3})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 120; // Much more blur for softer stars
                    ctx.shadowColor = `hsla(${this.hue}, 85%, 50%, ${this.opacity})`;
                    ctx.fill();
                    
                    // Add subtle outline
                    ctx.strokeStyle = `hsla(${this.hue}, 90%, 60%, ${this.opacity * 0.4})`;
                    ctx.lineWidth = 2;
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                } else {
                    // Waves (default)
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const wobble = Math.sin(angle * this.frequency + (time * 0.02) + this.phase) * this.amplitude;
                        const r = this.radius + wobble;
                        const px = this.x + Math.cos(angle) * r;
                        const py = this.y + Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    
                    ctx.strokeStyle = `hsla(${this.hue}, 85%, 50%, ${this.opacity})`;
                    ctx.lineWidth = this.thickness;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.shadowBlur = 50; // Softer glow for calmer effect
                    ctx.shadowColor = `hsla(${this.hue}, 85%, 40%, ${this.opacity * 0.7})`;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        function spawnSensoryEffect(x, y, forceShape) {
            let hue;
            const [min, max] = activeHueRange;
            
            if (min === 0 && max === 360) {
                // Classic wheel cycle
                currentHue = (currentHue + hueShiftPerTouch) % 360;
                hue = currentHue;
            } else {
                // Random within restricted range
                hue = min + Math.random() * (max - min);
            }
            
            // Determine which shape to use
            let shapeToUse = forceShape || animationShape;
            
            if (shapeToUse === 'bubbles') {
                // Spawn bubbles from bottom of screen
                const bubbleCount = 8;
                for (let i = 0; i < bubbleCount; i++) {
                    const spreadX = x + (Math.random() - 0.5) * width * 0.4;
                    const hueVariation = hue + (Math.random() - 0.5) * 30;
                    elements.push(new Bubble(spreadX, y, hueVariation, i * 200));
                }
            } else {
                // Regular waves from center
                const waveCount = 2; // Reduced from 4
                for (let i = 0; i < waveCount; i++) {
                    elements.push(new FluidWave(x, y, hue, i * 800, shapeToUse));
                }
            }
            
            return shapeToUse;
        }

        let lastMoveTime = 0;

        function clearAllTimers() {
            if (cooldownTimer) clearTimeout(cooldownTimer);
            if (buttonRestoreTimer) clearTimeout(buttonRestoreTimer);
            cooldownTimer = null;
            buttonRestoreTimer = null;
        }

        function startCooldown(duration) {
            clearAllTimers();
            isCooldown = true;
            
            cooldownTimer = setTimeout(() => {
                isCooldown = false;
                cooldownTimer = null;
                // Restore button visibility after cooldown
                if (isSwitchEnabled) {
                    cueArea.style.opacity = '1';
                }
            }, duration);
        }

        function handleInteraction(e) {
            // 1. Ignore if interacting with specific UI elements
            if (e.target.id === 'cue-area' || settingsBtn.contains(e.target) || settingsDrawer.contains(e.target)) {
                return;
            }

            // 2. Prevent default browser behavior (scrolling/zooming) on the canvas area
            if (e.cancelable) e.preventDefault();

            // 3. Settings open check
            if (settingsDrawer.classList.contains('open')) return;

            // 4. Tap Mode check
            if (tapMode === 'button') return;

            // 5. Cooldown check - block immediately
            if (isCooldown) return;

            // 6. Determine cooldown duration
            let cooldownDuration;
            if (cooldownMode === 'animation') {
                cooldownDuration = 12000;
            } else if (cooldownMode === '8s') {
                cooldownDuration = 8000;
            } else if (cooldownMode === '10s') {
                cooldownDuration = 10000;
            }

            // 7. Spawn logic
            const processTouch = (clientX, clientY) => {
                spawnSensoryEffect(clientX, clientY);
            };

            if (e.changedTouches) {
                // Trigger for first touch only
                if (e.changedTouches.length > 0) {
                    processTouch(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                    startCooldown(cooldownDuration);
                }
            } else {
                // Mouse click
                processTouch(e.clientX, e.clientY);
                startCooldown(cooldownDuration);
            }
        }

        window.addEventListener('mousedown', handleInteraction);
        // REMOVED move listeners to prevent "spray"
        // window.addEventListener('mousemove', handleInteraction); 
        window.addEventListener('touchstart', handleInteraction, { passive: false });
        // window.addEventListener('touchmove', handleInteraction, { passive: false });

        const triggerCue = (e) => {
            e.stopPropagation();
            if (e.cancelable) e.preventDefault();
            if (settingsDrawer.classList.contains('open')) return;
            if (!isSwitchEnabled) return;

            // Cooldown check for button tap - block immediately
            if (isCooldown) return;

            clearAllTimers();
            
            // Determine cooldown duration
            let cooldownDuration;
            if (cooldownMode === 'animation') {
                cooldownDuration = 12000;
            } else if (cooldownMode === '8s') {
                cooldownDuration = 8000;
            } else if (cooldownMode === '10s') {
                cooldownDuration = 10000;
            }

            // Set cooldown immediately to prevent multiple triggers
            isCooldown = true;
            
            cueArea.style.opacity = '0.05';

            // Calculate center dynamically based on position
            const rect = cueArea.getBoundingClientRect();
            let centerX, centerY;

            // Logic for animation origin point
            if (currentPosition === 'pos-center') {
                centerX = rect.left + rect.width / 2;
                centerY = rect.top + rect.height / 2;
            } else if (currentPosition === 'pos-bottom') {
                centerX = rect.left + rect.width / 2;
                centerY = rect.top + 20;
            } else if (currentPosition === 'pos-top') {
                centerX = rect.left + rect.width / 2;
                centerY = rect.bottom - 20;
            } else if (currentPosition === 'pos-left') {
                centerX = rect.right - 20;
                centerY = rect.top + rect.height / 2;
            } else if (currentPosition === 'pos-right') {
                centerX = rect.left + 20;
                centerY = rect.top + rect.height / 2;
            }
            
            const spawnCount = 3;
            
            for(let i = 0; i < spawnCount; i++) {
                setTimeout(() => {
                    let spawnX = centerX + (Math.random() - 0.5) * 200;
                    let spawnY = centerY + (Math.random() - 0.5) * 150;
                    
                    // Keep within screen bounds
                    const padding = 100;
                    spawnX = Math.max(padding, Math.min(width - padding, spawnX));
                    spawnY = Math.max(padding, Math.min(height - padding, spawnY));
                    
                    spawnSensoryEffect(spawnX, spawnY, animationShape);
                }, i * 1200);
            }

            // Set cooldown timer
            cooldownTimer = setTimeout(() => {
                isCooldown = false;
                cooldownTimer = null;
            }, cooldownDuration);

            // Restore button visibility
            buttonRestoreTimer = setTimeout(() => {
                if (isSwitchEnabled) {
                    cueArea.style.opacity = '1';
                }
                buttonRestoreTimer = null;
            }, cooldownDuration);
        };

        cueArea.addEventListener('mousedown', triggerCue);
        cueArea.addEventListener('touchstart', triggerCue, { passive: false });

        function animate() {
            time++;
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.12)'; 
            ctx.fillRect(0, 0, width, height);

            if (elements.length > 0) {
                for (let i = elements.length - 1; i >= 0; i--) {
                    elements[i].update();
                    elements[i].draw();
                    
                    // Remove based on element type
                    if (elements[i] instanceof Bubble) {
                        if (elements[i].life <= 0 || elements[i].y < -elements[i].radius) {
                            elements.splice(i, 1);
                        }
                    } else {
                        if (elements[i].life <= 0 || elements[i].radius > elements[i].maxRadius) {
                            elements.splice(i, 1);
                        }
                    }
                }
            } else {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);
            }
            requestAnimationFrame(animate);
        }

        init();

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .catch(() => {
                        // Service worker registration failed, app still works without it
                    });
            });
        }
    </script>
</body>
</html>